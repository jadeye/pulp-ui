# .gitlab-ci.yml — Stable: working scans + clean HTML for Pages + WikiJS publish (proper Markdown)

include:
  - template: Jobs/SAST.gitlab-ci.yml
  - template: Jobs/Dependency-Scanning.gitlab-ci.yml
  - template: Jobs/Secret-Detection.gitlab-ci.yml

variables:
  # Set to "false" if you don't have Ultimate
  GITLAB_ADVANCED_SAST_ENABLED: "true"

  # Speed up scans by skipping noise
  SAST_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static,cypress,playwright-report,**/*.min.js,**/*.map"
  DS_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static"
  SECRET_DETECTION_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static"

# Only create pipelines for: MRs, default branch pushes, or schedules
workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "schedule"
    - when: never

# SAST (Semgrep or Advanced SAST)
semgrep-sast:
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: on_success
    - changes:
        - "**/*.js"
        - "**/*.jsx"
        - "**/*.ts"
        - "**/*.tsx"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH && $CI_COMMIT_BEFORE_SHA == "0000000000000000000000000000000000000000"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: on_success
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - when: never

# Dependency Scanning (Gemnasium)
gemnasium-dependency_scanning:
  variables:
    DS_LOCK_FILE_PATHS: "yarn.lock,package-lock.json,pnpm-lock.yaml,**/yarn.lock,**/package-lock.json,**/pnpm-lock.yaml"
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: on_success
    - changes:
        - yarn.lock
        - package-lock.json
        - pnpm-lock.yaml
        - "**/yarn.lock"
        - "**/package-lock.json"
        - "**/pnpm-lock.yaml"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH && $CI_COMMIT_BEFORE_SHA == "0000000000000000000000000000000000000000"
      exists:
        - yarn.lock
        - package-lock.json
        - pnpm-lock.yaml
        - "**/yarn.lock"
        - "**/package-lock.json"
        - "**/pnpm-lock.yaml"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: on_success
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - when: never

# Secret Detection (Gitleaks ruleset)
secret_detection:
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: on_success
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - when: never

stages:
  - test
  - build
  - deploy
  - security
  - report

generate_security_report:
  stage: report
  image: alpine:3.19
  needs:
    - job: semgrep-sast
      artifacts: true
    - job: gemnasium-dependency_scanning
      artifacts: true
    - job: secret_detection
      artifacts: true
  before_script:
    - apk add --no-cache jq
  script: |
    set -e
    mkdir -p out

    md=out/security-report.md
    html=out/security-report.html

    echo "== Debug: downloaded security artifacts =="
    find . -maxdepth 3 -type f \( -name "gl-*-report.json" -o -name "gl-sbom-*.cdx.json" \) | sort || true

    SAST_JSON="${SAST_JSON:-gl-sast-report.json}"
    DS_JSON="${DS_JSON:-gl-dependency-scanning-report.json}"
    SECRETS_JSON="${SECRETS_JSON:-gl-secret-detection-report.json}"

    # locate DS report if not at root
    if [ ! -f "$DS_JSON" ]; then
      DS_JSON_FOUND=$(find . -type f -name "gl-dependency-scanning-report.json" | head -n1 || true)
      if [ -n "$DS_JSON_FOUND" ]; then
        echo "Using DS report at: $DS_JSON_FOUND"
        DS_JSON="$DS_JSON_FOUND"
      else
        echo "WARNING: Dependency Scanning report not found. Was the job skipped?"
      fi
    fi

    echo "# Security Report" > "$md"
    echo "" >> "$md"
    echo "_Generated on $(date -u +"%Y-%m-%d %H:%M:%SZ")_" >> "$md"
    echo "" >> "$md"

    summarize() {
      title="$1"; file="$2"
      echo "## $title" >> "$md"
      if [ -f "$file" ]; then
        count=$(jq '.vulnerabilities | length' "$file" 2>/dev/null || echo 0)
        echo "" >> "$md"
        echo "Findings: $count" >> "$md"
        echo "" >> "$md"
        if [ "$count" -gt 0 ]; then
          echo "| Severity | Category | Name | File | Lines |" >> "$md"
          echo "|---|---|---|---|---|" >> "$md"
          jq -r '
            (.vulnerabilities // [])[]
            | [
                (.severity // "unknown"),
                (.category // "unknown"),
                (.name // "n/a"),
                (.location.file // "n/a"),
                (
                  ( (.location.start_line // "")|tostring )
                  + (if .location.end_line then "-" + ((.location.end_line)|tostring) else "" end)
                )
              ]
            | @tsv
          ' "$file" | awk -F'	' '{printf("| %s | %s | %s | %s | %s |",$1,$2,$3,$4,$5)}' >> "$md"
        else
          echo "_No vulnerabilities detected._" >> "$md"
        fi
      else
        echo "" >> "$md"
        echo "_Report not found (job may have been skipped)._" >> "$md"
      fi
      echo "" >> "$md"
    }

    summarize "SAST" "$SAST_JSON"
    summarize "Dependency Scanning" "$DS_JSON"
    summarize "Secret Detection" "$SECRETS_JSON"

    # Build real HTML (no markdown-to-html awk to avoid table issues)
    {
      cat <<'HEAD'
        <!doctype html>
        <meta charset="utf-8">
        <title>Security Report</title>
        <style>
          body{font-family:sans-serif;max-width:980px;margin:32px auto;padding:0 16px}
          table{border-collapse:collapse;width:100%}
          th,td{border:1px solid #ddd;padding:8px}
          th{background:#f5f5f5;text-align:left}
          h1,h2{margin:0.6em 0}
          .muted{color:#666}
        </style>
        <article>
        HEAD

      echo "<h1>Security Report</h1>"
      echo "<p class='muted'>Generated on $(date -u +"%Y-%m-%d %H:%M:%SZ")</p>"

      render_html_section () {
        title="$1"; file="$2"
        echo "<h2>${title}</h2>"
        if [ -f "$file" ]; then
          count=$(jq '.vulnerabilities | length' "$file" 2>/dev/null || echo 0)
          echo "<p><strong>Findings:</strong> $count</p>"
          if [ "$count" -gt 0 ]; then
            echo "<table><thead><tr><th>Severity</th><th>Category</th><th>Name</th><th>File</th><th>Lines</th></tr></thead><tbody>"
            jq -r '
              def esc: tostring | gsub("&";"&amp;") | gsub("<";"&lt;");
              (.vulnerabilities // [])[] as $v
              | [
                  ($v.severity // "unknown") | esc,
                  ($v.category // "unknown") | esc,
                  ($v.name // "n/a") | esc,
                  ($v.location.file // "n/a") | esc,
                  (
                    ( ($v.location.start_line // "")|tostring )
                    + (if $v.location.end_line then "-" + (($v.location.end_line)|tostring) else "" end)
                  ) | esc
                ]
              | "<tr><td>" + .[0] + "</td><td>" + .[1] + "</td><td>" + .[2] + "</td><td>" + .[3] + "</td><td>" + .[4] + "</td></tr>"
            ' "$file"
            echo "</tbody></table>"
          else
            echo "<p><em>No vulnerabilities detected.</em></p>"
          fi
        else
          echo "<p><em>Report not found (job may have been skipped).</em></p>"
        fi
      }

      render_html_section "SAST" "$SAST_JSON"
      render_html_section "Dependency Scanning" "$DS_JSON"
      render_html_section "Secret Detection" "$SECRETS_JSON"

      echo "</article>"
    } > "$html"

  artifacts:
    name: "security-report"
    when: always
    expire_in: 30 days
    paths:
      - out/security-report.md
      - out/security-report.html
    expose_as: "Security Report"
  rules:
    - when: always

# Publish the HTML report on GitLab Pages
pages:
  stage: report
  needs:
    - job: generate_security_report
      artifacts: true
  script:
    - mkdir -p public
    - cp out/security-report.html public/index.html
  artifacts:
    paths:
      - public
  rules:
    - when: always

# Publish to WikiJS with RAW Markdown (no escaped \n)
publish_wikijs:
  stage: report
  image: alpine:3.19
  needs:
    - job: generate_security_report
      artifacts: true
  variables:
    WIKI_TITLE: "Pulp UI Security Report (Latest)"
    WIKI_DESCRIPTION: "Security report for pulp-ui (auto-generated)"
    WIKI_TAGS: "security,report,pulp-ui"
    WIKI_LOCALE: "en"   # set your default locale here
    # Set these in CI/CD → Variables:
    # WIKI_URL, WIKI_TOKEN, (optional) WIKI_PATH
  before_script:
    - set -eux
    - apk add --no-cache curl jq ca-certificates coreutils
    - test -f out/security-report.md
    - test -n "${WIKI_URL:-}"   || { echo "WIKI_URL required"; exit 1; }
    - test -n "${WIKI_TOKEN:-}" || { echo "WIKI_TOKEN required"; exit 1; }
  script: |
    set -euo pipefail

    PROJECT_SLUG="${CI_PROJECT_PATH_SLUG:-${CI_PROJECT_NAME:-project}}"
    TARGET_PATH="${WIKI_PATH:-security/${PROJECT_SLUG}/latest}"
    MD_RAW="$(cat out/security-report.md)"
    TAGS_JSON=$(printf '%s' "${WIKI_TAGS:-}" | jq -Rs 'split(",") | map(gsub("^[[:space:]]+|[[:space:]]+$";"")) | map(select(length>0))')

    call_gql () {
      curl -sS -H "Authorization: Bearer ${WIKI_TOKEN}" -H "Content-Type: application/json"         --data "$1" "${WIKI_URL%/}/graphql"
    }

    # Lookup page by path
    GET=$(jq -cn --arg path "$TARGET_PATH" --arg locale "$WIKI_LOCALE"       '{query:"query($path:String!,$locale:String!){ pages { singleByPath(path:$path, locale:$locale){ id } } }",
        variables:{path:$path, locale:$locale}}')
    RES=$(call_gql "$GET"); ID=$(echo "$RES" | jq -r '.data.pages.singleByPath.id // empty')

    if [ -n "$ID" ]; then
      # Update existing page with RAW markdown
      UP=$(jq -cn --argjson id "$ID" --arg content "$MD_RAW"         '{query:"mutation($id:Int!,$content:String!){ pages { update(id:$id, content:$content){ responseResult{ succeeded message } } } }",
          variables:{id:$id, content:$content}}')
      call_gql "$UP" >/dev/null || true  # do not fail pipeline on update quirks
    else
      # Create new page with RAW markdown
      CR=$(jq -cn         --arg path "$TARGET_PATH" --arg title "${WIKI_TITLE}" --arg locale "$WIKI_LOCALE"         --arg desc "${WIKI_DESCRIPTION}" --arg content "$MD_RAW" --argjson tags "$TAGS_JSON"         '{query:"mutation($path:String!,$title:String!,$locale:String!,$description:String!,$tags:[String]!, $content:String!){ pages { create(path:$path, title:$title, locale:$locale, editor:"markdown", isPublished:true, isPrivate:false, description:$description, tags:$tags, content:$content){ responseResult{ succeeded message } page{ id path } } } }",
          variables:{path:$path, title:$title, locale:$locale, description:$desc, tags:$tags, content:$content}}')
      call_gql "$CR" >/dev/null
    fi
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: on_success
    - when: never