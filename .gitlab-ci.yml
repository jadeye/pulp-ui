# .gitlab-ci.yml — Stable with bulletproof report + Pages + WikiJS (fixed before_script)

include:
  - template: Jobs/SAST.gitlab-ci.yml
  - template: Jobs/Dependency-Scanning.gitlab-ci.yml
  - template: Jobs/Secret-Detection.gitlab-ci.yml

stages:
  - test
  - build
  - deploy
  - security
  - report

variables:
  GITLAB_ADVANCED_SAST_ENABLED: "true"
  SAST_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static,cypress,playwright-report,**/*.min.js,**/*.map"
  DS_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static"
  SECRET_DETECTION_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static"
  REPORTS_EXPIRE_IN: 180 days

workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "schedule"
    - when: never

semgrep-sast:
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: on_success
    - changes:
        - "**/*.js"
        - "**/*.jsx"
        - "**/*.ts"
        - "**/*.tsx"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH && $CI_COMMIT_BEFORE_SHA == "0000000000000000000000000000000000000000"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: on_success
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - when: never

gemnasium-dependency_scanning:
  artifacts:
    when: always
    paths:
      - gl-dependency-scanning-report.json
      - gl-sbom-*.cdx.json
  variables:
    DS_LOCK_FILE_PATHS: "yarn.lock,package-lock.json,pnpm-lock.yaml,**/yarn.lock,**/package-lock.json,**/pnpm-lock.yaml"
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: on_success
    - changes:
        - yarn.lock
        - package-lock.json
        - pnpm-lock.yaml
        - "**/yarn.lock"
        - "**/package-lock.json"
        - "**/pnpm-lock.yaml"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH && $CI_COMMIT_BEFORE_SHA == "0000000000000000000000000000000000000000"
      exists:
        - yarn.lock
        - package-lock.json
        - pnpm-lock.yaml
        - "**/yarn.lock"
        - "**/package-lock.json"
        - "**/pnpm-lock.yaml"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: on_success
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - when: never

secret_detection:
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: on_success
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - when: never


# ---- Trivy CVE scan (filesystem; always pass) ----
trivy_scan:
  stage: test
  image: alpine:3.19
  variables:
    TRIVY_CACHE_DIR: .trivycache
  before_script:
    - apk add --no-cache curl ca-certificates tar >/dev/null
    - curl -sSL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
    - mkdir -p "$TRIVY_CACHE_DIR"
  script:
    - touch trivy-report.txt trivy-report.json trivy-report.cdx.json
    - trivy fs --cache-dir "$TRIVY_CACHE_DIR" --exit-code 0 --severity UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL --format table --output trivy-report.txt .
    - trivy fs --cache-dir "$TRIVY_CACHE_DIR" --exit-code 0 --severity UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL --format json  --output trivy-report.json .
    - trivy fs --cache-dir "$TRIVY_CACHE_DIR" --exit-code 0 --format cyclonedx --output trivy-report.cdx.json .
  cache:
    key: trivy-db-protected
    policy: pull-push
    paths:
      - .trivycache/
  artifacts:
    when: always
    paths:
      - trivy-report.txt
      - trivy-report.json
      - trivy-report.cdx.json

# --- Generate colorized MD + HTML + archive copies ---
generate_security_report:
  stage: report
  image: alpine:3.19
  needs:
    - job: trivy_scan
      artifacts: true
    - job: semgrep-sast
      artifacts: true
    - job: gemnasium-dependency_scanning
      artifacts: true
    - job: secret_detection
      artifacts: true
  before_script:
    - apk add --no-cache jq
  script: |
    set -e
    mkdir -p out

    md=out/security-report.md
    html=out/security-report.html

    echo "== Debug: downloaded security artifacts =="
    find . -maxdepth 3 -type f \( -name "gl-*-report.json" -o -name "gl-sbom-*.cdx.json" -o -name "trivy-report.json" \) | sort || true

    SAST_JSON="${SAST_JSON:-gl-sast-report.json}"
    DS_JSON="${DS_JSON:-gl-dependency-scanning-report.json}"
    SECRETS_JSON="${SECRETS_JSON:-gl-secret-detection-report.json}"
    TRIVY_JSON="${TRIVY_JSON:-trivy-report.json}"

    # Locate DS report if it isn't at repo root
    if [ ! -f "$DS_JSON" ]; then
      DS_JSON_FOUND=$(find . -type f -name "gl-dependency-scanning-report.json" | head -n1 || true)
      if [ -n "$DS_JSON_FOUND" ]; then
        echo "Using DS report at: $DS_JSON_FOUND"
        DS_JSON="$DS_JSON_FOUND"
      else
        echo "WARNING: Dependency Scanning report not found. Was the job skipped?"
      fi
    fi

    md="out/security-report.md"
    color_md="out/security-report.color.md"
    html="out/security-report.html"

    {
      echo "# Security Report"
      echo
      echo "_Generated on $(date -u +"%Y-%m-%d %H:%M:%SZ")_"
      echo
    } > "$md"

    summarize() {
      title="$1"; file="$2"
      {
        echo "## $title"
        if [ -f "$file" ]; then
          count=$(jq '.vulnerabilities | length' "$file" 2>/dev/null || echo 0)
          echo
          echo "Findings: $count"
          echo
          if [ "$count" -gt 0 ]; then
            echo "| Severity |  | File | Lines | Issue |"
            echo "|---|---|---|---|---|"
            if [ "$title" = "Dependency Scanning" ]; then
              # ---- DS rows: manifest-driven; no per-line location ----
              jq -r '
                def esc: tostring | gsub("\\|"; "&#124;");
                (.vulnerabilities // [])[] as $v
                | [
                    ($v.severity // "UNKNOWN") | esc,
                    ($v.category // "dependency_scanning") | esc,
                    (
                      $v.name
                      // $v.identifiers[0]?.name
                      // $v.message
                      // $v.id
                      // "n/a"
                    ) | esc,
                    ($v.location.file // "n/a") | esc,
                    "-"  # lockfiles don’t have meaningful line numbers
                  ]
                | @tsv
              ' "$file" 2>/dev/null \
              | awk -F'\t' '{printf("| %s | %s | %s | %s | %s |\n",$1,$2,$3,$4,$5)}'
            else
              # ---- SAST rows: code locations with start/end lines ----
              jq -r '
                def esc: tostring | gsub("\\|"; "&#124;");
                (.vulnerabilities // [])[] as $v
                | [
                    ($v.severity // "UNKNOWN") | esc,
                    ($v.category // "sast") | esc,
                    (
                      $v.name
                      // $v.identifiers[0]?.name
                      // "n/a"
                    ) | esc,
                    ($v.location.file // "n/a") | esc,
                    (
                      [ $v.location.start_line?, $v.location.end_line? ]
                      | map(tostring)
                      | del(.[] | select(. == "" or . == "null"))
                      | join("-")
                    ) | esc
                  ]
                | @tsv
              ' "$file" 2>/dev/null \
              | awk -F'\t' '{printf("| %s | %s | %s | %s | %s |\n",$1,$2,$3,$4,($5==""?"-":$5))}'
            fi
          else
            echo "_No vulnerabilities detected._"
          fi
        else
          echo
          echo "_Report not found (job may have been skipped)._"
        fi
        echo
      } >> "$md" || true
    }

    summarize "SAST" "$SAST_JSON"
    summarize "Dependency Scanning" "$DS_JSON"
    summarize "Secret Detection" "$SECRETS_JSON"

    # Trivy section
    echo "## Trivy" >> "$md"
    if [ -f "$TRIVY_JSON" ]; then
      count=$(jq '[.Results[]?.Vulnerabilities[]?] | length' "$TRIVY_JSON" 2>/dev/null || echo 0)
      echo "" >> "$md"
      echo "Findings: $count" >> "$md"
      echo "" >> "$md"
      if [ "$count" -gt 0 ]; then
        echo "| Severity | ID | Title | Package@Version (Target) | Fix |" >> "$md"
        echo "|---|---|---|---|---|" >> "$md"
        jq -r '
          (.Results[]? | .Target as $t
            | (.Vulnerabilities // [])[]?
            | [
                (.Severity // "UNKNOWN"),
                (.VulnerabilityID // "n/a"),
                (.Title // .PkgName // "n/a"),
                ((.PkgName // "pkg") + "@" + (.InstalledVersion // "?") + " (" + $t + ")"),
                (.FixedVersion // "n/a")
              ] | @tsv
          )
        ' "$TRIVY_JSON" 2>/dev/null \
        | awk -F'\t' '{printf("| %s | %s | %s | %s | %s |\n",$1,$2,$3,$4,$5)}' >> "$md"
      else
        echo "_No vulnerabilities detected by Trivy._" >> "$md"
      fi
    else
      echo "" >> "$md"
      echo "_Trivy report not found (job may have been skipped)._" >> "$md"
    fi

    # ---------- Linkify CVE IDs in Markdown (BEFORE colorization/HTML) ----------
    # Default NVD; set CVE_LINK_BASE in CI to switch (e.g. https://cve.mitre.org/cgi-bin/cvename.cgi?name=)
    CVE_BASE="${CVE_LINK_BASE:-https://nvd.nist.gov/vuln/detail}"
    case "$CVE_BASE" in *\?*) CVE_JOIN='' ;; *) CVE_JOIN='/' ;; esac

    # BusyBox sed: use -r (not -E) and a non-/ delimiter to avoid escaping URLs
    if ! sed -r -i \
      "s#(CVE-[0-9]{4}-[0-9]{4,7})#<a href=\"${CVE_BASE}${CVE_JOIN}\1\" target=\"_blank\" rel=\"noopener noreferrer\">\\1</a>#g" \
      "$md"; then
      echo "sed failed; applying awk fallback for CVE linkification"
      awk -v base="$CVE_BASE" -v join="$CVE_JOIN" '{
        gsub(/CVE-[0-9]{4}-[0-9]{4,7}/,
             "<a href=\"" base join "&\" target=\"_blank\" rel=\"noopener noreferrer\">" "&" "</a>")
        print
      }' "$md" > "$md.tmp" && mv "$md.tmp" "$md"
    fi

    # ---------- Colorize copy for Pages HTML (leave original MD clean for WikiJS) ----------
    # Create a colorized copy for GitLab Pages
    COLOR_MD="out/security-report.color.md"
    cp "$md" "$COLOR_MD"

    # Colorize ONLY the first table cell (severity) on each row to avoid overmatching "info" in filenames, etc.
    # BusyBox sed -> use -r (ERE)
    sed -ri \
      -e 's/^(\|[[:space:]]*)(CRITICAL|Critical)([[:space:]]*\|)/\1<span style="color:#d32f2f"><strong>\2<\/strong><\/span>\3/' \
      -e 's/^(\|[[:space:]]*)(HIGH|High)([[:space:]]*\|)/\1<span style="color:#ef6c00"><strong>\2<\/strong><\/span>\3/' \
      -e 's/^(\|[[:space:]]*)(MEDIUM|Medium)([[:space:]]*\|)/\1<span style="color:#f9a825"><strong>\2<\/strong><\/span>\3/' \
      -e 's/^(\|[[:space:]]*)(LOW|Low)([[:space:]]*\|)/\1<span style="color:#2e7d32"><strong>\2<\/strong><\/span>\3/' \
      -e 's/^(\|[[:space:]]*)(INFO|Info)([[:space:]]*\|)/\1<span style="color:#1565c0"><strong>\2<\/strong><\/span>\3/' \
      -e 's/^(\|[[:space:]]*)(UNKNOWN|Unknown)([[:space:]]*\|)/\1<span style="color:#757575"><strong>\2<\/strong><\/span>\3/' \
      "$COLOR_MD"

    # Safety fallback
    [ -s "$COLOR_MD" ] || cp "$md" "$COLOR_MD"
    # If colorized MD is empty, use the original clean MD
    # ---------- Build HTML from the colorized MD ----------
    {
      echo "<!doctype html><meta charset='utf-8'><title>Security Report</title>"
      echo "<style>body{font-family:sans-serif;max-width:980px;margin:32px auto;padding:0 16px} table{border-collapse:collapse;width:100%} th,td{border:1px solid #ddd;padding:8px} th{background:#f5f5f5;text-align:left} code{background:#f6f8fa;padding:2px 4px;border-radius:4px}</style>"
      echo "<article>"
      awk '
        /^# /{print "<h1>"substr($0,3)"</h1>";next}
        /^## /{print "<h2>"substr($0,4)"</h2>";next}
        /^\|/{
          if (!intable){print "<table>"; intable=1}
          gsub(/^\||\|$/,""); n=split($0, a, /\|/)
          if (!header_done){ print "<tr>"; for(i=1;i<=n;i++) print "<th>"a[i]"</th>"; print "</tr>"; header_done=1; next }
          print "<tr>"; for(i=1;i<=n;i++) print "<td>"a[i]"</td>"; print "</tr>"; next
        }
        { if (intable){print "</table>"; intable=0; header_done=0} print "<p>"$0"</p>"}
        END{ if (intable){print "</table>"} }
      ' "$COLOR_MD" || true
      echo "</article>"
    } > "$html" || true

    # Archive copies
    TS="$(date -u +%Y-%m-%d_%H-%M-%S)"
    cp "$md"   "out/security-report-${TS}.md"
    cp "$html" "out/security-report-${TS}.html"

  artifacts:
    name: "security-report-${CI_PIPELINE_ID}"
    when: always
    expire_in: '180 days'
    paths:
      - out/security-report.md
      - out/security-report.html
    expose_as: "Security Report"
  rules:
    - when: always

# --- GitLab Pages (latest + all archived HTML) ---
pages:
  stage: report
  needs:
    - job: generate_security_report
      artifacts: true
  script:
    - mkdir -p public public/reports
    - cp out/security-report.html public/index.html
    - cp out/*.html public/reports/ || true
  artifacts:
    paths:
      - public
    expire_in: '180 days'
  rules:
    - when: always

# --- WikiJS publish (optional; set WIKI_URL + WIKI_TOKEN) ---
publish_wikijs:
  stage: report
  image: alpine:3.19
  needs:
    - job: generate_security_report
      artifacts: true
  variables:
    WIKI_TITLE: "Pulp UI Security Report (Latest)"
    WIKI_DESCRIPTION: "Security report for pulp-ui (auto-generated)"
    WIKI_TAGS: "security,report,pulp-ui"
    WIKI_LOCALE: "en"
  before_script:
    - set -euo pipefail
    - apk add --no-cache curl jq ca-certificates coreutils >/dev/null
    - test -f out/security-report.md || { echo "security-report.md missing"; ls -la out || true; exit 1; }
    - if [ -z "${WIKI_URL:-}" ]; then echo "WIKI_URL required"; exit 1; fi
    - if [ -z "${WIKI_TOKEN:-}" ]; then echo "WIKI_TOKEN required"; exit 1; fi
  script: |
    set -euo pipefail

    call_gql () {
      # $1 payload file, $2 output json
      http=$(curl -sS -o "$2" -w '%{http_code}' \
        -H "Authorization: Bearer ${WIKI_TOKEN}" \
        -H "Content-Type: application/json" \
        --data @"$1" "${WIKI_URL%/}/graphql")
      echo "HTTP $http" >> wikijs-debug/http.log
      [ "$http" = "200" ] || { echo "GraphQL HTTP $http (see $2)"; cat "$2" || true; exit 1; }
    }

    upsert () {
      # args: path title content desc tags locale
      local path="$1" title="$2" content="$3" desc="$4" tags_raw="$5" locale="$6"

      mkdir -p wikijs-debug

      # Lookup by path
      jq -cn --arg path "$path" --arg locale "$locale" '
        {query:"query($path:String!,$locale:String!){ pages { singleByPath(path:$path, locale:$locale){ id path title } } }",
         variables:{path:$path, locale:$locale}}' > wikijs-debug/get.payload.json
      call_gql wikijs-debug/get.payload.json wikijs-debug/get.json

      id="$(jq -r '.data.pages.singleByPath.id // empty' wikijs-debug/get.json)"
      if [ -n "$id" ]; then
        echo "Updating page id=$id ($path)"
        jq -cn --arg id "$id" --arg content "$content" --arg desc "$desc" --arg tags_raw "$tags_raw" '
          def mk_tags($s):
            if ($s|length)>0 then ($s|split(",") | map(gsub("^[[:space:]]+|[[:space:]]+$";"")) | map(select(length>0))) else [] end;
          {query:"mutation($id:Int!,$content:String!,$description:String!,$tags:[String]!){ pages { update(id:$id, content:$content, description:$description, tags:$tags, isPublished:true){ responseResult{ succeeded message } } } }",
           variables:{ id:($id|tonumber), content:$content, description:$desc, tags: mk_tags($tags_raw) }}' > wikijs-debug/update.payload.json
        call_gql wikijs-debug/update.payload.json wikijs-debug/update.json
        jq -e '.data.pages.update.responseResult.succeeded == true' wikijs-debug/update.json >/dev/null || {
          echo "Update failed:"; jq '.data.pages.update.responseResult // .errors' wikijs-debug/update.json; exit 1; }
      else
        echo "Creating new page at $path"
        jq -cn --arg path "$path" --arg title "$title" --arg locale "$locale" \
               --arg desc "$desc" --arg content "$content" --arg tags_raw "$tags_raw" '
          def mk_tags($s):
            if ($s|length)>0 then ($s|split(",") | map(gsub("^[[:space:]]+|[[:space:]]+$";"")) | map(select(length>0))) else [] end;
          {query:"mutation($path:String!,$title:String!,$locale:String!,$description:String!,$tags:[String]!, $content:String!){ pages { create(path:$path, title:$title, locale:$locale, editor:\"markdown\", isPublished:true, isPrivate:false, description:$description, tags:$tags, content:$content){ responseResult{ succeeded message } page{ id path } } } }",
           variables:{ path:$path, title:$title, locale:$locale, description:$desc, tags: mk_tags($tags_raw), content:$content }}' > wikijs-debug/create.payload.json
        call_gql wikijs-debug/create.payload.json wikijs-debug/create.json
        jq -e '.data.pages.create.responseResult.succeeded == true' wikijs-debug/create.json >/dev/null || {
          echo "Create failed:"; jq '.data.pages.create.responseResult // .errors' wikijs-debug/create.json; exit 1; }
      fi
    }

    PROJECT_SLUG="${CI_PROJECT_PATH_SLUG:-${CI_PROJECT_NAME:-project}}"
    TARGET_PATH="${WIKI_PATH:-security/${PROJECT_SLUG}/latest}"

    # Colorize Markdown severity for WikiJS (first cell only)
    WIKI_MD="out/security-report.wikijs.md"
    cp out/security-report.md "$WIKI_MD"
    sed -ri \
      -e 's/^(\|[[:space:]]*)(CRITICAL|Critical)([[:space:]]*\|)/\1<span style="color:#d32f2f"><strong>\2<\/strong><\/span>\3/' \
      -e 's/^(\|[[:space:]]*)(HIGH|High)([[:space:]]*\|)/\1<span style="color:#ef6c00"><strong>\2<\/strong><\/span>\3/' \
      -e 's/^(\|[[:space:]]*)(MEDIUM|Medium)([[:space:]]*\|)/\1<span style="color:#f9a825"><strong>\2<\/strong><\/span>\3/' \
      -e 's/^(\|[[:space:]]*)(LOW|Low)([[:space:]]*\|)/\1<span style="color:#2e7d32"><strong>\2<\/strong><\/span>\3/' \
      -e 's/^(\|[[:space:]]*)(INFO|Info)([[:space:]]*\|)/\1<span style="color:#1565c0"><strong>\2<\/strong><\/span>\3/' \
      -e 's/^(\|[[:space:]]*)(UNKNOWN|Unknown)([[:space:]]*\|)/\1<span style="color:#757575"><strong>\2<\/strong><\/span>\3/' \
      "$WIKI_MD"
    [ -s "$WIKI_MD" ] || cp out/security-report.md "$WIKI_MD"

    MD_RAW="$(cat "$WIKI_MD")"
    DESC="${WIKI_DESCRIPTION:-Security report for ${CI_PROJECT_NAME:-project} (auto-generated)}"
    TAGS_RAW="${WIKI_TAGS:-}"

    mkdir -p wikijs-debug
    # Update "latest"
    upsert "$TARGET_PATH" "${WIKI_TITLE}" "$MD_RAW" "$DESC" "$TAGS_RAW" "${WIKI_LOCALE:-en}"
    echo "WikiJS page up to date: $TARGET_PATH"
    # --- Archive this exact run (UTC timestamp, URL-safe) ---
    # UTC
    # DATESTAMP="${REPORT_TIMESTAMP:-$(date -u '+%Y-%m-%d_%H-%M-%SZ')}"
    # local time (Asia/Jerusalem) 
    DATESTAMP="$(TZ='Asia/Jerusalem' date '+%Y-%m-%d_%H-%M-%S%z' | sed 's/+/-/')"  # e.g. 2025-08-14_16-03-00+0300 → 2025-08-14_16-03-00-0300
    ARCHIVE_PATH="${WIKI_ARCHIVE_PATH:-security/${PROJECT_SLUG}/${DATESTAMP}}"
    ARCHIVE_TITLE="${WIKI_TITLE} - ${DATESTAMP}"

    upsert "$ARCHIVE_PATH" "$ARCHIVE_TITLE" "$MD_RAW" "$DESC" "$TAGS_RAW" "${WIKI_LOCALE:-en}"
    echo "WikiJS archive page up to date: $ARCHIVE_PATH"

    echo "WikiJS page up to date: $TARGET_PATH"

  artifacts:
    when: always
    expire_in: '180 days'
    paths:
      - wikijs-debug
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: on_success
    - when: never


### LAST WORKING VERSION
# # .gitlab-ci.yml — Stable with bulletproof report + Pages + WikiJS (fixed before_script)

# include:
#   - template: Jobs/SAST.gitlab-ci.yml
#   - template: Jobs/Dependency-Scanning.gitlab-ci.yml
#   - template: Jobs/Secret-Detection.gitlab-ci.yml

# variables:
#   GITLAB_ADVANCED_SAST_ENABLED: "true"
#   SAST_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static,cypress,playwright-report,**/*.min.js,**/*.map"
#   DS_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static"
#   SECRET_DETECTION_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static"

# workflow:
#   rules:
#     - if: $CI_PIPELINE_SOURCE == "merge_request_event"
#     - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
#     - if: $CI_PIPELINE_SOURCE == "schedule"
#     - when: never

# semgrep-sast:
#   rules:
#     - if: $CI_PIPELINE_SOURCE == "schedule"
#       when: on_success
#     - changes:
#         - "**/*.js"
#         - "**/*.jsx"
#         - "**/*.ts"
#         - "**/*.tsx"
#       when: on_success
#     - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH && $CI_COMMIT_BEFORE_SHA == "0000000000000000000000000000000000000000"
#       when: on_success
#     - if: $CI_PIPELINE_SOURCE == "merge_request_event"
#       when: on_success
#     - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
#       when: on_success
#     - when: never

# gemnasium-dependency_scanning:
#   artifacts:
#     when: always
#     paths:
#       - gl-dependency-scanning-report.json
#       - gl-sbom-*.cdx.json
#   variables:
#     DS_LOCK_FILE_PATHS: "yarn.lock,package-lock.json,pnpm-lock.yaml,**/yarn.lock,**/package-lock.json,**/pnpm-lock.yaml"
#   rules:
#     - if: $CI_PIPELINE_SOURCE == "schedule"
#       when: on_success
#     - changes:
#         - yarn.lock
#         - package-lock.json
#         - pnpm-lock.yaml
#         - "**/yarn.lock"
#         - "**/package-lock.json"
#         - "**/pnpm-lock.yaml"
#       when: on_success
#     - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH && $CI_COMMIT_BEFORE_SHA == "0000000000000000000000000000000000000000"
#       exists:
#         - yarn.lock
#         - package-lock.json
#         - pnpm-lock.yaml
#         - "**/yarn.lock"
#         - "**/package-lock.json"
#         - "**/pnpm-lock.yaml"
#       when: on_success
#     - if: $CI_PIPELINE_SOURCE == "merge_request_event"
#       when: on_success
#     - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
#       when: on_success
#     - when: never

# secret_detection:
#   rules:
#     - if: $CI_PIPELINE_SOURCE == "schedule"
#       when: on_success
#     - if: $CI_PIPELINE_SOURCE == "merge_request_event"
#       when: on_success
#     - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
#       when: on_success
#     - when: never

# stages:
#   - test
#   - build
#   - deploy
#   - security
#   - report

# generate_security_report:
#   stage: report
#   image: alpine:3.19
#   needs:
#     - job: semgrep-sast
#       artifacts: true
#     - job: gemnasium-dependency_scanning
#       artifacts: true
#     - job: secret_detection
#       artifacts: true
#   before_script:
#     - apk add --no-cache jq
#   script: |
#     set -e
#     mkdir -p out

#     md=out/security-report.md
#     html=out/security-report.html

#     echo "== Debug: downloaded security artifacts =="
#     find . -maxdepth 3 -type f \( -name "gl-*-report.json" -o -name "gl-sbom-*.cdx.json" \) | sort || true

#     SAST_JSON="${SAST_JSON:-gl-sast-report.json}"
#     DS_JSON="${DS_JSON:-gl-dependency-scanning-report.json}"
#     SECRETS_JSON="${SECRETS_JSON:-gl-secret-detection-report.json}"

#     # locate DS report if not at root
#     if [ ! -f "$DS_JSON" ]; then
#       DS_JSON_FOUND=$(find . -type f -name "gl-dependency-scanning-report.json" | head -n1 || true)
#       if [ -n "$DS_JSON_FOUND" ]; then
#         echo "Using DS report at: $DS_JSON_FOUND"
#         DS_JSON="$DS_JSON_FOUND"
#       else
#         echo "WARNING: Dependency Scanning report not found. Was the job skipped?"
#       fi
#     fi

#     {
#       echo "# Security Report"
#       echo
#       echo "_Generated on $(date -u +"%Y-%m-%d %H:%M:%SZ")_"
#       echo
#     } > "$md"

#     summarize() {
#       title="$1"; file="$2"
#       {
#         echo "## $title"
#         if [ -f "$file" ]; then
#           count=$(jq '.vulnerabilities | length' "$file" 2>/dev/null || echo 0)
#           echo
#           echo "Findings: $count"
#           echo
#           if [ "$count" -gt 0 ]; then
#             echo "| Severity |  | File | Lines | Result |"
#             echo "|---|---|---|---|---|"
#             # inside summarize() in generate_security_report
#             # header: | Severity | Category | Name | File | Lines |
#             jq -r '
#               def esc: tostring | gsub("\\|"; "&#124;");
#               (.vulnerabilities // [])[] as $v
#               | [
#                   ($v.severity // "unknown") | esc,
#                   ($v.category // "unknown") | esc,
#                   ($v.name // "n/a") | esc,
#                   ($v.location.file // "n/a") | esc,
#                   (
#                     ( ($v.location.start_line // "")|tostring )
#                     + (if $v.location.end_line then "-" + (($v.location.end_line)|tostring) else "" end)
#                   ) | esc
#                 ]
#               | @tsv
#             ' "$file" 2>/dev/null \
#             | awk -F'\t' '{printf("| %s | %s | %s | %s | %s |\n",$1,$2,$3,$4,$5)}' || {
#               echo "_(Failed to render table rows)_"
#             }
#           else
#             echo "_No vulnerabilities detected._"
#           fi
#         else
#           echo
#           echo "_Report not found (job may have been skipped)._"
#         fi
#         echo
#       } >> "$md" || true
#     }

#     summarize "SAST" "$SAST_JSON"
#     summarize "Dependency Scanning" "$DS_JSON"
#     summarize "Secret Detection" "$SECRETS_JSON"
#     # Create colorized copy for Pages HTML (leave original Markdown for WikiJS)
#     COLOR_MD="out/security-report.color.md"
#     sed -E \
#       -e 's/\b(Critical)\b/<span style="color:#d32f2f"><strong>\1<\/strong><\/span>/g' \
#       -e 's/\b(High)\b/<span style="color:#ef6c00"><strong>\1<\/strong><\/span>/g' \
#       -e 's/\b(Medium)\b/<span style="color:#f9a825"><strong>\1<\/strong><\/span>/g' \
#       -e 's/\b(Low)\b/<span style="color:#2e7d32"><strong>\1<\/strong><\/span>/g' \
#       -e 's/\b(Info)\b/<span style="color:#1565c0"><strong>\1<\/strong><\/span>/g' \
#       "$md" > "$COLOR_MD"


#     {
#       echo "<!doctype html><meta charset='utf-8'><title>Security Report</title>"
#       echo "<style>body{font-family:sans-serif;max-width:980px;margin:32px auto;padding:0 16px} table{border-collapse:collapse;width:100%} th,td{border:1px solid #ddd;padding:8px} th{background:#f5f5f5;text-align:left}</style>"
#       echo "<article>"
#       awk '
#         /^# /{print "<h1>"substr($0,3)"</h1>";next}
#         /^## /{print "<h2>"substr($0,4)"</h2>";next}
#         /^\|/{
#           if (!intable){print "<table>"; intable=1}
#           gsub(/^\||\|$/,""); n=split($0, a, /\|/)
#           if (!header_done){ print "<tr>"; for(i=1;i<=n;i++) print "<th>"a[i]"</th>"; print "</tr>"; header_done=1; next }
#           print "<tr>"; for(i=1;i<=n;i++) print "<td>"a[i]"</td>"; print "</tr>"; next
#         }
#         { if (intable){print "</table>"; intable=0; header_done=0} print "<p>"$0"</p>"}
#         END{ if (intable){print "</table>"} }
#       ' "$COLOR_MD" || true
#       echo "</article>"
#     } > "$html" || true

#     if [ ! -s "$html" ]; then
#       echo "HTML was empty or missing; writing fallback."
#       {
#         echo "<!doctype html><meta charset='utf-8'><title>Security Report</title><pre>"
#         sed 's/&/\&amp;/g; s/</\&lt;/g' "$COLOR_MD"
#         echo "</pre>"
#       } > "$html"
#     fi

#   artifacts:
#     name: "security-report"
#     when: always
#     expire_in: 30 days
#     paths:
#       - out/security-report.md
#       - out/security-report.html
#     expose_as: "Security Report"
#   rules:
#     - when: always

# pages:
#   stage: report
#   needs:
#     - job: generate_security_report
#       artifacts: true
#   script:
#     - mkdir -p public
#     - cp out/security-report.html public/index.html
#   artifacts:
#     paths:
#       - public
#   rules:
#     - when: always

# publish_wikijs:
#   stage: report
#   image: alpine:3.19
#   needs:
#     - job: generate_security_report
#       artifacts: true
#   variables:
#     WIKI_TITLE: "Pulp UI Security Report (Latest)"
#     WIKI_DESCRIPTION: "Security report for pulp-ui (auto-generated)"
#     WIKI_TAGS: "security,report,pulp-ui"
#     WIKI_LOCALE: "en"
#   before_script:
#     - set -euo pipefail
#     - apk add --no-cache curl jq ca-certificates coreutils
#     - test -f out/security-report.md || { echo "security-report.md missing"; ls -la out || true; exit 1; }
#     - if [ -z "${WIKI_URL:-}" ]; then echo "WIKI_URL required"; exit 1; fi
#     - if [ -z "${WIKI_TOKEN:-}" ]; then echo "WIKI_TOKEN required"; exit 1; fi
#   script: |
#     set -euo pipefail

#     PROJECT_SLUG="${CI_PROJECT_PATH_SLUG:-${CI_PROJECT_NAME:-project}}"
#     TARGET_PATH="${WIKI_PATH:-security/${PROJECT_SLUG}/latest}"
#     MD_RAW="$(cat out/security-report.md \
#     | sed -E 's/\b(Critical)\b/<span style=\"color:#d32f2f\"><strong>\1<\/strong><\/span>/g' \
#     | sed -E 's/\b(High)\b/<span style=\"color:#ef6c00\"><strong>\1<\/strong><\/span>/g' \
#     | sed -E 's/\b(Medium)\b/<span style=\"color:#f9a825\"><strong>\1<\/strong><\/span>/g' \
#     | sed -E 's/\b(Low)\b/<span style=\"color:#2e7d32\"><strong>\1<\/strong><\/span>/g' \
#     | sed -E 's/\b(Info)\b/<span style=\"color:#1565c0\"><strong>\1<\/strong><\/span>/g')"

#     DESC="${WIKI_DESCRIPTION:-Security report for ${CI_PROJECT_NAME:-project} (auto-generated)}"
#     TAGS_RAW="${WIKI_TAGS:-}"
#     mkdir -p wikijs-debug

#     call_gql () {
#       # $1 payload file, $2 output json
#       http=$(curl -sS -o "$2" -w '%{http_code}' \
#         -H "Authorization: Bearer ${WIKI_TOKEN}" \
#         -H "Content-Type: application/json" \
#         --data @"$1" "${WIKI_URL%/}/graphql")
#       echo "HTTP $http" >> wikijs-debug/http.log
#       [ "$http" = "200" ] || { echo "GraphQL HTTP $http (see $2)"; cat "$2" || true; exit 1; }
#     }

#     # 1) Lookup by path (minimal fields)
#     jq -cn --arg path "$TARGET_PATH" --arg locale "${WIKI_LOCALE:-en}" '
#       {query:"query($path:String!,$locale:String!){ pages { singleByPath(path:$path, locale:$locale){ id path title } } }",
#        variables:{path:$path, locale:$locale}}' > wikijs-debug/get.payload.json
#     if ! call_gql wikijs-debug/get.payload.json wikijs-debug/get.json; then
#       echo "Retrying singleByPath without locale..."
#       jq -cn --arg path "$TARGET_PATH" '
#         {query:"query($path:String!){ pages { singleByPath(path:$path){ id path title } } }",
#          variables:{path:$path}}' > wikijs-debug/get.nolocale.payload.json
#       call_gql wikijs-debug/get.nolocale.payload.json wikijs-debug/get.json
#     fi

#     ID="$(jq -r '.data.pages.singleByPath.id // empty' wikijs-debug/get.json)"

#     if [ -n "$ID" ]; then
#       echo "Updating page id=$ID ($TARGET_PATH)"
#       # 2) Update existing page — send description & tags (array built inside jq), publish=true
#       jq -cn --arg id "$ID" --arg content "$MD_RAW" --arg desc "$DESC" --arg tags_raw "$TAGS_RAW" '
#         def mk_tags($s):
#           if ($s|length)>0 then
#             ($s|split(",") | map(gsub("^[[:space:]]+|[[:space:]]+$";"")) | map(select(length>0)))
#           else [] end;
#         {
#           query:"mutation($id:Int!,$content:String!,$description:String!,$tags:[String]!){ pages { update(id:$id, content:$content, description:$description, tags:$tags, isPublished:true){ responseResult{ succeeded message } } } }",
#           variables:{ id:($id|tonumber), content:$content, description:$desc, tags: mk_tags($tags_raw) }
#         }' > wikijs-debug/update.payload.json
#       call_gql wikijs-debug/update.payload.json wikijs-debug/update.json
#       jq -e '.data.pages.update.responseResult.succeeded == true' wikijs-debug/update.json >/dev/null || {
#         echo "Update failed:"; jq '.data.pages.update.responseResult // .errors' wikijs-debug/update.json; exit 1; }
#     else
#       echo "Creating new page at $TARGET_PATH"
#       # 3) Create new page — editor markdown + published, tags built in jq
#       jq -cn --arg path "$TARGET_PATH" --arg title "${WIKI_TITLE}" --arg locale "${WIKI_LOCALE:-en}" \
#              --arg desc "$DESC" --arg content "$MD_RAW" --arg tags_raw "$TAGS_RAW" '
#         def mk_tags($s):
#           if ($s|length)>0 then
#             ($s|split(",") | map(gsub("^[[:space:]]+|[[:space:]]+$";"")) | map(select(length>0)))
#           else [] end;
#         {
#           query:"mutation($path:String!,$title:String!,$locale:String!,$description:String!,$tags:[String]!, $content:String!){ pages { create(path:$path, title:$title, locale:$locale, editor:\"markdown\", isPublished:true, isPrivate:false, description:$description, tags:$tags, content:$content){ responseResult{ succeeded message } page{ id path } } } }",
#           variables:{ path:$path, title:$title, locale:$locale, description:$desc, tags: mk_tags($tags_raw), content:$content }
#         }' > wikijs-debug/create.payload.json
#       call_gql wikijs-debug/create.payload.json wikijs-debug/create.json
#       jq -e '.data.pages.create.responseResult.succeeded == true' wikijs-debug/create.json >/dev/null || {
#         echo "Create failed:"; jq '.data.pages.create.responseResult // .errors' wikijs-debug/create.json; exit 1; }
#     fi

#     echo "WikiJS page up to date: $TARGET_PATH"

#   artifacts:
#     when: always
#     paths:
#       - wikijs-debug
  
#   rules:
#     - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
#       when: on_success
#     - if: $CI_PIPELINE_SOURCE == "merge_request_event"
#       when: on_success
#     - if: $CI_PIPELINE_SOURCE == "schedule"
#       when: on_success
#     - when: never
### END OF LAST WORKING VERSION
