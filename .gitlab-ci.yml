# .gitlab-ci.yml — Security scans for a JS/TS frontend repo, with HTML coloring, CWE links, and WikiJS auto-archive

include:
  - template: Jobs/SAST.gitlab-ci.yml
  - template: Jobs/Dependency-Scanning.gitlab-ci.yml
  - template: Jobs/Secret-Detection.gitlab-ci.yml

variables:
  # Set to "false" if you don't have Ultimate
  GITLAB_ADVANCED_SAST_ENABLED: "true"

  # Speed up scans by skipping noise
  SAST_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static,cypress,playwright-report,**/*.min.js,**/*.map"
  DS_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static"
  SECRET_DETECTION_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static"

# Only create pipelines for: MRs, default branch pushes, or schedules
workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "schedule"
    - when: never

# SAST (Semgrep or Advanced SAST)
# Runs when JS/TS files change, on schedules, on main pushes,
# and once on any new branch for a baseline scan
semgrep-sast:
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: on_success
    - changes:
        - "**/*.js"
        - "**/*.jsx"
        - "**/*.ts"
        - "**/*.tsx"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH && $CI_COMMIT_BEFORE_SHA == "0000000000000000000000000000000000000000"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: on_success
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - when: never

# Dependency Scanning (Gemnasium)
# Runs on: schedules; when lockfiles change; on MRs; on main pushes;
# and once on any new branch (baseline) *if lockfiles exist*
gemnasium-dependency_scanning:
  variables:
    # help Gemnasium find nested lockfiles
    DS_LOCK_FILE_PATHS: "yarn.lock,package-lock.json,pnpm-lock.yaml,**/yarn.lock,**/package-lock.json,**/pnpm-lock.yaml"
  rules:
    # schedules: always
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: on_success

    # run when lockfiles change (any branch/MR)
    - changes:
        - yarn.lock
        - package-lock.json
        - pnpm-lock.yaml
        - "**/yarn.lock"
        - "**/package-lock.json"
        - "**/pnpm-lock.yaml"
      when: on_success

    # first push on a new non-default branch (baseline) if lockfiles exist (root or nested)
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH && $CI_COMMIT_BEFORE_SHA == "0000000000000000000000000000000000000000"
      exists:
        - yarn.lock
        - package-lock.json
        - pnpm-lock.yaml
        - "**/yarn.lock"
        - "**/package-lock.json"
        - "**/pnpm-lock.yaml"
      when: on_success

    # all MRs
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: on_success

    # pushes to default branch (main)
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success

    # fallback: never
    - when: never

# Secret Detection (Gitleaks ruleset)
# Runs on: schedules, MRs, and main pushes
secret_detection:
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: on_success
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - when: never

stages:
  - test
  - build
  - deploy
  - security
  - report

generate_security_report:
  stage: report
  image: alpine:3.19
  needs:
    - job: semgrep-sast
      artifacts: true
    - job: gemnasium-dependency_scanning
      artifacts: true
    - job: secret_detection
      artifacts: true
  before_script:
    - apk add --no-cache jq
  script: |
    set -e
    mkdir -p out

    md=out/security-report.md
    html=out/security-report.html

    echo "== Debug: downloaded security artifacts =="
    find . -maxdepth 3 -type f \( -name "gl-*-report.json" -o -name "gl-sbom-*.cdx.json" \) | sort || true

    SAST_JSON="${SAST_JSON:-gl-sast-report.json}"
    DS_JSON="${DS_JSON:-gl-dependency-scanning-report.json}"
    SECRETS_JSON="${SECRETS_JSON:-gl-secret-detection-report.json}"

    # Try to locate DS report if not at repo root
    DS_NOTE=""
    if [ ! -f "$DS_JSON" ]; then
      DS_JSON_FOUND=$(find . -type f -name "gl-dependency-scanning-report.json" | head -n1 || true)
      if [ -n "$DS_JSON_FOUND" ]; then
        echo "Using DS report at: $DS_JSON_FOUND"
        DS_JSON="$DS_JSON_FOUND"
        DS_NOTE="_(Using: $DS_JSON_FOUND)_"
      else
        echo "WARNING: Dependency Scanning report not found. Was the job skipped?"
      fi
    fi

    # Build Markdown
    {
      echo "# Security Report"
      echo
      echo "_Generated on $(date -u +"%Y-%m-%d %H:%M:%SZ")_"
      echo
    } > "$md"

    summarize() {
      title="$1"; file="$2"
      echo "## $title" >> "$md"
      if [ -f "$file" ]; then
        count=$(jq '.vulnerabilities | length' "$file" 2>/dev/null || echo 0)
        echo >> "$md"
        echo "**Findings:** $count" >> "$md"
        echo >> "$md"
        if [ "$count" -gt 0 ]; then
          # Enhanced columns: add CWE (with link) and emit severity as HTML span with class
          echo "| Severity | Category | Name | File | Lines | CWE |" >> "$md"
          echo "|---|---|---|---|---|---|" >> "$md"
          jq -r '
            (.vulnerabilities // [])[]
            | . as $v
            | ($v.severity // "unknown") as $sev_raw
            | ($sev_raw | ascii_downcase) as $sev_lc
            | ("<span class=\"sev sev-" + $sev_lc + "\">" + ($sev_raw) + "</span>") as $sev_html
            | (
                (
                  [ ($v.identifiers // [])[]
                      | select((.type // "") == "cwe")
                      | (.name // .value // "")
                      | capture("CWE-(?<n>[0-9]+)")?.n
                  ]
                  | map(select(. != null)) | .[0]
                ) // ($v.cwe // null)
              ) as $cwe
            | (
                if $cwe then
                  ("<a href=\"https://cwe.mitre.org/data/definitions/" + ($cwe|tostring) + ".html\" target=\"_blank\">CWE-" + ($cwe|tostring) + "</a>")
                else "" end
              ) as $cwe_html
            | [
                $sev_html,
                ($v.category // "unknown"),
                ($v.name // "n/a"),
                ($v.location.file // "n/a"),
                (
                  ( ($v.location.start_line // "")|tostring )
                  + (if $v.location.end_line then "-" + (($v.location.end_line)|tostring) else "" end)
                ),
                $cwe_html
              ]
            | @tsv
          ' "$file" | awk -F"\t" '{printf("| %s | %s | %s | %s | %s | %s |\n",$1,$2,$3,$4,$5,$6)}' >> "$md"
        else
          echo "_No vulnerabilities detected._" >> "$md"
        fi
      else
        echo >> "$md"
        echo "_Report not found (job may have been skipped)._" >> "$md"
      fi
      echo >> "$md"
    }

    summarize "SAST" "$SAST_JSON"
    summarize "Dependency Scanning" "$DS_JSON"
    [ -n "$DS_NOTE" ] && echo "$DS_NOTE" >> "$md" && echo >> "$md"
    summarize "Secret Detection" "$SECRETS_JSON"

    # Minimal HTML wrapper with severity colors
    {
      echo "<!doctype html><meta charset='utf-8'><title>Security Report</title>"
      cat <<'CSS'
      <style>
        body{font-family:sans-serif;max-width:980px;margin:32px auto;padding:0 16px}
        table{border-collapse:collapse;width:100%} th,td{border:1px solid #ddd;padding:8px}
        th{background:#f5f5f5;text-align:left}
        .sev{border-radius:14px;padding:2px 10px;display:inline-block;font-weight:600}
        .sev-critical{background:#3b0d0d;color:#ffe4e4;border:1px solid #a11}
        .sev-high{background:#fee2e2;color:#9f1239;border:1px solid #fecaca}
        .sev-medium{background:#fffbeb;color:#92400e;border:1px solid #fde68a}
        .sev-low{background:#ecfeff;color:#075985;border:1px solid #bae6fd}
        .sev-info,.sev-unknown{background:#f3f4f6;color:#374151;border:1px solid #e5e7eb}
      </style>
      CSS
      echo "<article>"
      awk '
        /^# /{print "<h1>"substr($0,3)"</h1>";next}
        /^## /{print "<h2>"substr($0,4)"</h2>";next}
        /^\|/{
          if (!intable){print "<table>"; intable=1}
          gsub(/^\||\|$/,""); n=split($0, a, /\|/)
          if (!header_done){ print "<tr>"; for(i=1;i<=n;i++) print "<th>"a[i]"</th>"; print "</tr>"; header_done=1; next }
          print "<tr>"; for(i=1;i<=n;i++) print "<td>"a[i]"</td>"; print "</tr>"; next
        }
        { if (intable){print "</table>"; intable=0; header_done=0} print "<p>"$0"</p>"}
        END{ if (intable){print "</table>"} }
      ' "$md"
      echo "</article>"
    } > "$html"

  artifacts:
    name: "security-report"
    when: always
    expire_in: 30 days
    paths:
      - out/security-report.md
      - out/security-report.html
    expose_as: "Security Report"
  rules:
    - when: always


# Publish the HTML report on GitLab Pages
pages:
  stage: report
  needs:
    - job: generate_security_report
      artifacts: true
  script:
    - mkdir -p public
    - cp out/security-report.html public/index.html
  artifacts:
    paths:
      - public
  rules:
    - when: always

publish_wikijs:
  stage: report
  image: alpine:3.19
  needs:
    - job: generate_security_report
      artifacts: true
  variables:
    WIKI_TITLE: "Pulp UI Security Report"
    WIKI_DESCRIPTION: "Security report for pulp-ui (auto-generated)"
    WIKI_TAGS: "security,report,pulp-ui"
    WIKI_ARCHIVE: "true"            # <-- auto-archive dated snapshot
    # Set these in CI/CD → Variables
    # WIKI_URL, WIKI_TOKEN, (optional) WIKI_LOCALE=en, (optional) WIKI_PATH
  before_script:
    - set -eux
    - apk add --no-cache curl jq ca-certificates coreutils
    - test -f out/security-report.md
    - test -n "${WIKI_URL:-}"   || { echo "WIKI_URL required"; exit 1; }
    - test -n "${WIKI_TOKEN:-}" || { echo "WIKI_TOKEN required"; exit 1; }
    - mkdir -p wikijs-debug
    # Auto-detect default locale if not provided
    - |
      if [ -z "${WIKI_LOCALE:-}" ]; then
        curl -sS -o wikijs-debug/locale.json -w '%{http_code}'           -H "Authorization: Bearer ${WIKI_TOKEN}"           -H "Content-Type: application/json"           --data '{"query":"{ localization { config { locale } } }"}'           "${WIKI_URL%/}/graphql" > wikijs-debug/locale_http.txt
        export WIKI_LOCALE=$(jq -r '.data.localization.config.locale' wikijs-debug/locale.json)
        [ -n "$WIKI_LOCALE" ] || { echo "Could not auto-detect locale"; cat wikijs-debug/locale.json; exit 1; }
      fi
  script: |
    set -euo pipefail

    PROJECT_SLUG="${CI_PROJECT_PATH_SLUG:-${CI_PROJECT_NAME:-project}}"
    TARGET_PATH="${WIKI_PATH:-security/${PROJECT_SLUG}/latest}"
    ARCHIVE_PATH="security/${PROJECT_SLUG}/$(date -u +%F)"
    MD_RAW="$(cat out/security-report.md)"
    TAGS_JSON=$(printf '%s' "${WIKI_TAGS:-}" | jq -Rs 'split(",") | map(gsub("^\s+|\s+$";"")) | map(select(length>0))')

    call_gql () {
      curl -sS -H "Authorization: Bearer ${WIKI_TOKEN}" -H "Content-Type: application/json"         --data "$1" "${WIKI_URL%/}/graphql"
    }

    # lookup
    GET=$(jq -cn --arg path "$TARGET_PATH" --arg locale "$WIKI_LOCALE"       '{query:"query($path:String!,$locale:String!){ pages { singleByPath(path:$path, locale:$locale){ id } } }",
        variables:{path:$path, locale:$locale}}')
    RES=$(call_gql "$GET"); ID=$(echo "$RES" | jq -r '.data.pages.singleByPath.id // empty')

    create_payload () {
      jq -cn         --arg path "$1" --arg title "$2" --arg locale "$WIKI_LOCALE"         --arg desc "${WIKI_DESCRIPTION}" --arg content "$MD_RAW" --argjson tags "$TAGS_JSON"         '{query:"mutation($path:String!,$title:String!,$locale:String!,$description:String!,$tags:[String]!, $content:String!){ pages { create(path:$path, title:$title, locale:$locale, editor:"markdown", isPublished:true, isPrivate:false, description:$description, tags:$tags, content:$content){ responseResult{ succeeded message } page{ id path } } } }",
          variables:{path:$path, title:$title, locale:$locale, description:$desc, tags:$tags, content:$content}}'
    }

    if [ -n "$ID" ]; then
      # update; if it fails, delete+create
      UP=$(jq -cn --argjson id "$ID" --arg content "$MD_RAW"         '{query:"mutation($id:Int!,$content:String!){ pages { update(id:$id, content:$content){ responseResult{ succeeded message } } } }",
          variables:{id:$id, content:$content}}')
      RES=$(call_gql "$UP"); OK=$(echo "$RES" | jq -r '.data.pages.update.responseResult.succeeded // false')
      if [ "$OK" != "true" ]; then
        DEL=$(jq -cn --argjson id "$ID"           '{query:"mutation($id:Int!){ pages { delete(id:$id){ responseResult{ succeeded message } } } }",
            variables:{id:$id}}')
        call_gql "$DEL" >/dev/null
        RES=$(call_gql "$(create_payload "$TARGET_PATH" "${WIKI_TITLE} (Latest)")")
        echo "$RES" | jq -e '.errors|not and .data.pages.create.responseResult.succeeded==true' >/dev/null
      fi
    else
      RES=$(call_gql "$(create_payload "$TARGET_PATH" "${WIKI_TITLE} (Latest)")")
      echo "$RES" | jq -e '.errors|not and .data.pages.create.responseResult.succeeded==true' >/dev/null
    fi

    # Auto-archive snapshot (dated)
    if [ "${WIKI_ARCHIVE,,}" = "true" ]; then
      RES=$(call_gql "$(create_payload "$ARCHIVE_PATH" "${WIKI_TITLE} ($(date -u +%F))")")
      echo "$RES" | jq -e '.errors|not and .data.pages.create.responseResult.succeeded==true' >/dev/null
    fi
  artifacts:
    when: on_failure
    paths:
      - wikijs-debug/
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "schedule"