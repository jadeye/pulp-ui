# .gitlab-ci.yml — Security scans for a JS/TS frontend repo

include:
  - template: Jobs/SAST.gitlab-ci.yml
  - template: Jobs/Dependency-Scanning.gitlab-ci.yml
  - template: Jobs/Secret-Detection.gitlab-ci.yml

variables:
  # Set to "false" if you don't have Ultimate
  GITLAB_ADVANCED_SAST_ENABLED: "true"

  # Speed up scans by skipping noise
  SAST_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static,cypress,playwright-report,**/*.min.js,**/*.map"
  DS_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static"
  SECRET_DETECTION_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static"

# Only create pipelines for: MRs, default branch pushes, or schedules
workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "schedule"
    - when: never

# SAST (Semgrep or Advanced SAST)
# Runs when JS/TS files change, on schedules, on main pushes,
# and once on any new branch for a baseline scan
semgrep-sast:
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: on_success
    - changes:
        - "**/*.js"
        - "**/*.jsx"
        - "**/*.ts"
        - "**/*.tsx"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH && $CI_COMMIT_BEFORE_SHA == "0000000000000000000000000000000000000000"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: on_success
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - when: never

# Dependency Scanning (Gemnasium)
# Runs on: schedules; when lockfiles change; on MRs; on main pushes;
# and once on any new branch (baseline) *if lockfiles exist*
gemnasium-dependency_scanning:
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: on_success
    - changes:
        - package-lock.json
        - yarn.lock
        - pnpm-lock.yaml
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH && $CI_COMMIT_BEFORE_SHA == "0000000000000000000000000000000000000000"
      exists:
        - package-lock.json
        - yarn.lock
        - pnpm-lock.yaml
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: on_success
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - when: never

# Secret Detection (Gitleaks ruleset)
# Runs on: schedules, MRs, and main pushes
secret_detection:
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: on_success
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - when: never

# stages:
#   - test
#   - build
#   - deploy
#   - security
#   - report

generate_security_report:
  stage: report
  image: alpine:3.19
  needs:
    - job: semgrep-sast
      artifacts: true
    - job: gemnasium-dependency_scanning
      artifacts: true
    - job: secret_detection
      artifacts: true
  before_script:
    - apk add --no-cache jq
  script: |
    set -e
    mkdir -p out

    md=out/security-report.md
    html=out/security-report.html

    echo "# Security Report" > "$md"
    echo "" >> "$md"
    echo "_Generated on $(date -u +"%Y-%m-%d %H:%M:%SZ")_" >> "$md"
    echo "" >> "$md"

    summarize() {
      title="$1"; file="$2"
      echo "## $title" >> "$md"
      if [ -f "$file" ]; then
        count=$(jq '.vulnerabilities | length' "$file" 2>/dev/null || echo 0)
        echo "" >> "$md"
        echo "**Findings:** $count" >> "$md"
        echo "" >> "$md"
        if [ "$count" -gt 0 ]; then
          echo "| Severity | Category | Name | File | Lines |" >> "$md"
          echo "|---|---|---|---|---|" >> "$md"
          jq -r '
            (.vulnerabilities // [])[]
            | [
                (.severity // "unknown"),
                (.category // "unknown"),
                (.name // "n/a"),
                (.location.file // "n/a"),
                (
                  ( (.location.start_line // "")|tostring )
                  + (if .location.end_line then "-" + ((.location.end_line)|tostring) else "" end)
                )
              ]
            | @tsv
          ' "$file" | awk -F'\t' '{printf("| %s | %s | %s | %s | %s |\n",$1,$2,$3,$4,$5)}' >> "$md"
        else
          echo "_No vulnerabilities detected._" >> "$md"
        fi
      else
        echo "" >> "$md"
        echo "_Report not found (job may have been skipped)._" >> "$md"
      fi
      echo "" >> "$md"
    }

    summarize "SAST" "gl-sast-report.json"
    summarize "Dependency Scanning" "gl-dependency-scanning-report.json"
    summarize "Secret Detection" "gl-secret-detection-report.json"

    # Minimal HTML wrapper so it renders nicely if you publish it
    {
      echo "<!doctype html><meta charset='utf-8'><title>Security Report</title>"
      echo "<style>body{font-family:sans-serif;max-width:980px;margin:32px auto;padding:0 16px} table{border-collapse:collapse;width:100%} th,td{border:1px solid #ddd;padding:8px} th{background:#f5f5f5;text-align:left}</style>"
      echo "<article>"
      # Convert simple Markdown to HTML-ish (headings + tables)
      awk '
        /^# /{print "<h1>"substr($0,3)"</h1>";next}
        /^## /{print "<h2>"substr($0,4)"</h2>";next}
        /^\|/{
          # table rows
          if (!intable){print "<table>"; intable=1}
          gsub(/^\||\|$/,""); n=split($0, a, /\|/)
          if (!header_done){ print "<tr>"; for(i=1;i<=n;i++) print "<th>"a[i]"</th>"; print "</tr>"; header_done=1; next }
          print "<tr>"; for(i=1;i<=n;i++) print "<td>"a[i]"</td>"; print "</tr>"; next
        }
        { if (intable){print "</table>"; intable=0; header_done=0} print "<p>"$0"</p>"}
        END{ if (intable){print "</table>"} }
      ' "$md"
      echo "</article>"
    } > "$html"

  artifacts:
    name: "security-report"
    when: always
    expire_in: 30 days
    paths:
      - out/security-report.md
      - out/security-report.html
    expose_as: "Security Report"
  rules:
    - when: always


# Publish the HTML report on GitLab Pages
pages:
  stage: report
  needs:
    - job: generate_security_report
      artifacts: true
  script:
    - mkdir -p public
    - cp out/security-report.html public/index.html
  artifacts:
    paths:
      - public
  rules:
    - when: always

publish_wikijs:
  stage: report
  image: alpine:3.19
  needs:
    - job: generate_security_report
      artifacts: true
  variables:
    # defaults; override via CI/CD → Variables if you like
    WIKI_LOCALE: "en"
    WIKI_TITLE: "Security Report"
    WIKI_ARCHIVE: "false"                   # set true to also write YYYY-MM-DD snapshot
    # Optional: WIKI_PATH (e.g., "pulp-ui/security/latest")
  before_script:
    - apk add --no-cache curl jq coreutils
  script: |
    set -e
    test -f out/security-report.html

    PROJECT_SLUG="${CI_PROJECT_PATH_SLUG:-${CI_PROJECT_NAME:-project}}"
    DEFAULT_PATH="security/${PROJECT_SLUG}/latest"
    TARGET_PATH="${WIKI_PATH:-$DEFAULT_PATH}"
    ARCHIVE_DATE="$(date -u +%F)"
    ARCHIVE_PATH="security/${PROJECT_SLUG}/${ARCHIVE_DATE}"

    HTML_JSON=$(jq -Rs . out/security-report.html)

    upsert_page () {
      local PATH="$1" TITLE="$2" CONTENT_JSON="$3"
      local GET='{"query":"query($path:String!,$locale:String!){ pages { singleByPath(path:$path, locale:$locale){ id path title } } }","variables":{"path":"'"$PATH"'","locale":"'"$WIKI_LOCALE"'"}}'
      local RES
      RES=$(curl -sS -H "Authorization: Bearer $WIKI_TOKEN" -H "Content-Type: application/json" \
        --data "$GET" "$WIKI_URL/graphql")
      local ID
      ID=$(echo "$RES" | jq -r '.data.pages.singleByPath.id // empty')

      if [ -n "$ID" ]; then
        echo "Updating ${PATH}"
        local MUT='{"query":"mutation($id:Int!,$content:String!){ pages { update(id:$id, content:$content){ responseResult{ succeeded message } } } }","variables":{"id":'"$ID"',"content":'"$CONTENT_JSON"'}}'
        curl -sS -H "Authorization: Bearer $WIKI_TOKEN" -H "Content-Type: application/json" \
          --data "$MUT" "$WIKI_URL/graphql" | tee /tmp/wikijs-update.json
        test "$(jq -r '.data.pages.update.responseResult.succeeded' /tmp/wikijs-update.json)" = "true"
      else
        echo "Creating ${PATH}"
        local MUT='{"query":"mutation($path:String!,$title:String!,$locale:String!,$content:String!){ pages { create(path:$path, title:$title, locale:$locale, editor:\"html\", isPublished:true, isPrivate:false, content:$content){ responseResult{ succeeded message } } } }","variables":{"path":"'"$PATH"'","title":"'"$WIKI_TITLE"'", "locale":"'"$WIKI_LOCALE"'", "content":'"$CONTENT_JSON"'}}'
        curl -sS -H "Authorization: Bearer $WIKI_TOKEN" -H "Content-Type: application/json" \
          --data "$MUT" "$WIKI_URL/graphql" | tee /tmp/wikijs-create.json
        test "$(jq -r '.data.pages.create.responseResult.succeeded' /tmp/wikijs-create.json)" = "true"
      fi
    }

    upsert_page "$TARGET_PATH" "${WIKI_TITLE} (Latest)" "$HTML_JSON"
    if [ "${WIKI_ARCHIVE,,}" = "true" ]; then
      upsert_page "$ARCHIVE_PATH" "${WIKI_TITLE} (${ARCHIVE_DATE})" "$HTML_JSON"
    fi
  artifacts:
    when: on_failure
    paths:
      - /tmp/wikijs-*.json
  rules:
    # publish on main and schedules by default (keep MR pipelines lighter)
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "schedule"


# # Security scans for a JS/TS frontend repo

# include:
#   # SAST (Semgrep; Advanced SAST if enabled)
#   - template: Jobs/SAST.gitlab-ci.yml
#   # Dependency Scanning (npm/yarn/pnpm)
#   - template: Jobs/Dependency-Scanning.gitlab-ci.yml
#   # Secret Detection (Gitleaks ruleset)
#   - template: Jobs/Secret-Detection.gitlab-ci.yml

# variables:
#   # Turn on deeper taint analysis if you have Ultimate
#   GITLAB_ADVANCED_SAST_ENABLED: "true"

#   # Trim scan scope for a frontend repo
#   SAST_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static,cypress,playwright-report,**/*.min.js,**/*.map"
#   DS_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static"
#   SECRET_DETECTION_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static"

# # Run on MRs and default branch
# sast:
#   rules:
#     - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# dependency_scanning:
#   rules:
#     - if: $CI_PIPELINE_SOURCE == "merge_request_event"
#     - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# secret_detection:
#   rules:
#     - if: $CI_PIPELINE_SOURCE == "merge_request_event"
#     - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
