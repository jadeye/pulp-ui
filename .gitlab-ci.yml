# .gitlab-ci.yml â€” Security scans for a JS/TS frontend repo

include:
  - template: Jobs/SAST.gitlab-ci.yml
  - template: Jobs/Dependency-Scanning.gitlab-ci.yml
  - template: Jobs/Secret-Detection.gitlab-ci.yml

variables:
  # Set to "false" if you don't have Ultimate
  GITLAB_ADVANCED_SAST_ENABLED: "true"

  # Speed up scans by skipping noise
  SAST_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static,cypress,playwright-report,**/*.min.js,**/*.map"
  DS_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static"
  SECRET_DETECTION_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static"

# Only create pipelines for: MRs, default branch pushes, or schedules
workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "schedule"
    - when: never

# SAST (Semgrep or Advanced SAST)
# Runs when JS/TS files change, on schedules, on main pushes,
# and once on any new branch for a baseline scan
semgrep-sast:
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: on_success
    - changes:
        - "**/*.js"
        - "**/*.jsx"
        - "**/*.ts"
        - "**/*.tsx"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH && $CI_COMMIT_BEFORE_SHA == "0000000000000000000000000000000000000000"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: on_success
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - when: never

# Dependency Scanning (Gemnasium)
# Runs on: schedules; when lockfiles change; on MRs; on main pushes;
# and once on any new branch (baseline) *if lockfiles exist*
gemnasium-dependency_scanning:
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: on_success
    - changes:
        - package-lock.json
        - yarn.lock
        - pnpm-lock.yaml
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH && $CI_COMMIT_BEFORE_SHA == "0000000000000000000000000000000000000000"
      exists:
        - package-lock.json
        - yarn.lock
        - pnpm-lock.yaml
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: on_success
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - when: never

# Secret Detection (Gitleaks ruleset)
# Runs on: schedules, MRs, and main pushes
secret_detection:
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: on_success
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - when: never

stages:
  - test
  - build
  - deploy
  - security
  - report

generate_security_report:
  stage: report
  image: alpine:3.19
  needs:
    - job: semgrep-sast
      artifacts: true
    - job: gemnasium-dependency_scanning
      artifacts: true
    - job: secret_detection
      artifacts: true
  before_script:
    - apk add --no-cache jq
  script: |
    set -e
    mkdir -p out

    md=out/security-report.md
    html=out/security-report.html

    echo "# Security Report" > "$md"
    echo "" >> "$md"
    echo "_Generated on $(date -u +"%Y-%m-%d %H:%M:%SZ")_" >> "$md"
    echo "" >> "$md"

    summarize() {
      title="$1"; file="$2"
      echo "## $title" >> "$md"
      if [ -f "$file" ]; then
        count=$(jq '.vulnerabilities | length' "$file" 2>/dev/null || echo 0)
        echo "" >> "$md"
        echo "**Findings:** $count" >> "$md"
        echo "" >> "$md"
        if [ "$count" -gt 0 ]; then
          echo "| Severity | Category | Name | File | Lines |" >> "$md"
          echo "|---|---|---|---|---|" >> "$md"
          jq -r '
            (.vulnerabilities // [])[]
            | [
                (.severity // "unknown"),
                (.category // "unknown"),
                (.name // "n/a"),
                (.location.file // "n/a"),
                (
                  ( (.location.start_line // "")|tostring )
                  + (if .location.end_line then "-" + ((.location.end_line)|tostring) else "" end)
                )
              ]
            | @tsv
          ' "$file" | awk -F'\t' '{printf("| %s | %s | %s | %s | %s |\n",$1,$2,$3,$4,$5)}' >> "$md"
        else
          echo "_No vulnerabilities detected._" >> "$md"
        fi
      else
        echo "" >> "$md"
        echo "_Report not found (job may have been skipped)._" >> "$md"
      fi
      echo "" >> "$md"
    }

    summarize "SAST" "gl-sast-report.json"
    summarize "Dependency Scanning" "gl-dependency-scanning-report.json"
    summarize "Secret Detection" "gl-secret-detection-report.json"

    # Minimal HTML wrapper so it renders nicely if you publish it
    {
      echo "<!doctype html><meta charset='utf-8'><title>Security Report</title>"
      echo "<style>body{font-family:sans-serif;max-width:980px;margin:32px auto;padding:0 16px} table{border-collapse:collapse;width:100%} th,td{border:1px solid #ddd;padding:8px} th{background:#f5f5f5;text-align:left}</style>"
      echo "<article>"
      # Convert simple Markdown to HTML-ish (headings + tables)
      awk '
        /^# /{print "<h1>"substr($0,3)"</h1>";next}
        /^## /{print "<h2>"substr($0,4)"</h2>";next}
        /^\|/{
          # table rows
          if (!intable){print "<table>"; intable=1}
          gsub(/^\||\|$/,""); n=split($0, a, /\|/)
          if (!header_done){ print "<tr>"; for(i=1;i<=n;i++) print "<th>"a[i]"</th>"; print "</tr>"; header_done=1; next }
          print "<tr>"; for(i=1;i<=n;i++) print "<td>"a[i]"</td>"; print "</tr>"; next
        }
        { if (intable){print "</table>"; intable=0; header_done=0} print "<p>"$0"</p>"}
        END{ if (intable){print "</table>"} }
      ' "$md"
      echo "</article>"
    } > "$html"

  artifacts:
    name: "security-report"
    when: always
    expire_in: 30 days
    paths:
      - out/security-report.md
      - out/security-report.html
    expose_as: "Security Report"
  rules:
    - when: always


# Publish the HTML report on GitLab Pages
pages:
  stage: report
  needs:
    - job: generate_security_report
      artifacts: true
  script:
    - mkdir -p public
    - cp out/security-report.html public/index.html
  artifacts:
    paths:
      - public
  rules:
    - when: always

publish_wikijs:
  stage: report
  image: alpine:3.19
  needs:
    - job: generate_security_report
      artifacts: true
  variables:
    WIKI_LOCALE: "en"
    WIKI_TITLE: "Security Report"
    WIKI_ARCHIVE: "false"  # set true to also write YYYY-MM-DD snapshot
  before_script:
    - set -eux
    - apk add --no-cache curl jq coreutils ca-certificates
    - test -f out/security-report.html
    - : "${WIKI_URL:?WIKI_URL is required (e.g. http://172.16.111.195:3000)}"
    - : "${WIKI_TOKEN:?WIKI_TOKEN is required (Wiki.js API token with manage:pages)}"
    - mkdir -p wikijs-debug
  script: |
    set -euo pipefail

    # Derive paths
    PROJECT_SLUG="${CI_PROJECT_PATH_SLUG:-${CI_PROJECT_NAME:-project}}"
    TARGET_PATH="${WIKI_PATH:-security/${PROJECT_SLUG}/latest}"
    ARCHIVE_PATH="security/${PROJECT_SLUG}/$(date -u +%F)"

    HTML_JSON=$(jq -Rs . out/security-report.html)

    call_gql () {
      # $1: JSON payload; writes response to $2 and returns non-zero on HTTP error
      local payload="$1" out="$2"
      http=$(
        curl -sS -o "$out" -w "%{http_code}" \
          -H "Authorization: Bearer ${WIKI_TOKEN}" \
          -H "Content-Type: application/json" \
          --data "$payload" \
          "${WIKI_URL%/}/graphql"
      )
      echo "HTTP $http" | tee -a "wikijs-debug/http.log"
      [ "$http" = "200" ] || return 22
      return 0
    }

    upsert_page () {
      local path="$1" title="$2" content_json="$3"

      # 1) Lookup by path
      get_payload=$(jq -cn --arg path "$path" --arg locale "$WIKI_LOCALE" \
        '{query:"query($path:String!,$locale:String!){ pages { singleByPath(path:$path, locale:$locale){ id path title } } }",
          variables:{path:$path, locale:$locale}}')

      if ! call_gql "$get_payload" "wikijs-debug/get-$(echo "$path" | tr '/' '_').json"; then
        echo "GraphQL lookup failed (check token/URL). Response:"
        cat "wikijs-debug/get-$(echo "$path" | tr '/' '_').json" || true
        exit 1
      fi

      id=$(jq -r '.data.pages.singleByPath.id // empty' "wikijs-debug/get-$(echo "$path" | tr '/' '_').json")

      if [ -n "$id" ]; then
        echo "Updating page id=$id at $path"
        mut_payload=$(jq -cn --argjson id "$id" --arg content "$content_json" \
          '{query:"mutation($id:Int!,$content:String!){ pages { update(id:$id, content:$content){ responseResult{ succeeded message } } } }",
            variables:{id:$id, content:$content}}')

        if ! call_gql "$mut_payload" "wikijs-debug/update-$(echo "$path" | tr '/' '_').json"; then
          echo "GraphQL update failed. Response:"; cat "wikijs-debug/update-$(echo "$path" | tr '/' '_').json" || true; exit 1
        fi

        jq -e '.errors|not' "wikijs-debug/update-$(echo "$path" | tr '/' '_').json" >/dev/null || { echo "GraphQL errors:"; jq '.errors' "wikijs-debug/update-$(echo "$path" | tr '/' '_').json"; exit 1; }
        jq -e '.data.pages.update.responseResult.succeeded == true' "wikijs-debug/update-$(echo "$path" | tr '/' '_').json" >/dev/null || { jq '.data.pages.update.responseResult' "wikijs-debug/update-$(echo "$path" | tr '/' '_').json"; exit 1; }
      else
        echo "Creating page at $path"
        mut_payload=$(jq -cn --arg path "$path" --arg title "$title" --arg locale "$WIKI_LOCALE" --arg content "$content_json" \
          '{query:"mutation($path:String!,$title:String!,$locale:String!,$content:String!){ pages { create(path:$path, title:$title, locale:$locale, editor:\"html\", isPublished:true, isPrivate:false, content:$content){ responseResult{ succeeded message } } } }",
            variables:{path:$path, title:$title, locale:$locale, content:$content}}')

        if ! call_gql "$mut_payload" "wikijs-debug/create-$(echo "$path" | tr '/' '_').json"; then
          echo "GraphQL create failed. Response:"; cat "wikijs-debug/create-$(echo "$path" | tr '/' '_').json" || true; exit 1
        fi

        jq -e '.errors|not' "wikijs-debug/create-$(echo "$path" | tr '/' '_').json" >/dev/null || { echo "GraphQL errors:"; jq '.errors' "wikijs-debug/create-$(echo "$path" | tr '/' '_').json"; exit 1; }
        jq -e '.data.pages.create.responseResult.succeeded == true' "wikijs-debug/create-$(echo "$path" | tr '/' '_').json" >/dev/null || { jq '.data.pages.create.responseResult' "wikijs-debug/create-$(echo "$path" | tr '/' '_').json"; exit 1; }
      fi
    }

    upsert_page "$TARGET_PATH" "${WIKI_TITLE} (Latest)" "$HTML_JSON"
    if [ "${WIKI_ARCHIVE,,}" = "true" ]; then
      upsert_page "$ARCHIVE_PATH" "${WIKI_TITLE} ($(date -u +%F))" "$HTML_JSON"
    fi
  artifacts:
    when: on_failure
    paths:
      - wikijs-debug/
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "schedule"


# # Security scans for a JS/TS frontend repo

# include:
#   # SAST (Semgrep; Advanced SAST if enabled)
#   - template: Jobs/SAST.gitlab-ci.yml
#   # Dependency Scanning (npm/yarn/pnpm)
#   - template: Jobs/Dependency-Scanning.gitlab-ci.yml
#   # Secret Detection (Gitleaks ruleset)
#   - template: Jobs/Secret-Detection.gitlab-ci.yml

# variables:
#   # Turn on deeper taint analysis if you have Ultimate
#   GITLAB_ADVANCED_SAST_ENABLED: "true"

#   # Trim scan scope for a frontend repo
#   SAST_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static,cypress,playwright-report,**/*.min.js,**/*.map"
#   DS_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static"
#   SECRET_DETECTION_EXCLUDED_PATHS: "node_modules,dist,build,coverage,.next,.cache,storybook-static"

# # Run on MRs and default branch
# sast:
#   rules:
#     - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# dependency_scanning:
#   rules:
#     - if: $CI_PIPELINE_SOURCE == "merge_request_event"
#     - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# secret_detection:
#   rules:
#     - if: $CI_PIPELINE_SOURCE == "merge_request_event"
#     - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
